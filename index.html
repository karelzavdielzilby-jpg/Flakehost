<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grandmaster AI Chess</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              board: {
                light: '#e8edfa',
                dark: '#779556',
              }
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
            }
          }
        }
      }
    </script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      body {
        font-family: 'Inter', sans-serif;
        background-color: #111827;
        color: #f3f4f6;
      }
      /* Custom Scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1f2937; 
      }
      ::-webkit-scrollbar-thumb {
        background: #4b5563; 
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6b7280; 
      }
      
      .square {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
      }
      
      .piece {
        width: 80%;
        height: 80%;
        z-index: 10;
        transition: transform 0.1s;
      }
      
      .piece:hover {
        transform: scale(1.05);
      }

      .move-hint {
        position: absolute;
        width: 12px;
        height: 12px;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 50%;
        z-index: 5;
      }

      .capture-hint {
        position: absolute;
        width: 100%;
        height: 100%;
        border: 4px solid rgba(0, 0, 0, 0.2);
        border-radius: 50%;
        z-index: 5;
      }
    </style>
    <script type="importmap">
{
  "imports": {
    "chess.js": "https://aistudiocdn.com/chess.js@^1.4.0",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0",
    "react/": "https://aistudiocdn.com/react@^19.2.1/",
    "react": "https://aistudiocdn.com/react@^19.2.1"
  }
}
</script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body class="min-h-screen flex flex-col items-center py-8 px-4">
    
    <!-- Header -->
    <header class="mb-8 text-center">
      <h1 class="text-4xl font-extrabold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-cyan-500 to-cyan-500">
        Chess Practice
      </h1>
      <p class="text-gray-400 mt-2 text-sm">Powered by Gemini AI</p>
    </header>

    <!-- Main Content -->
    <div class="flex flex-col lg:flex-row gap-8 w-full max-w-6xl items-start justify-center">
      
      <!-- Left Column: Board -->
      <div class="flex flex-col gap-4 items-center w-full lg:w-auto">
        
        <!-- Opponent Info -->
        <div class="w-full max-w-[600px] flex justify-between items-end px-2">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-blue-600 flex items-center justify-center text-xs font-bold shadow-lg text-white">
                    AI
                </div>
                <div>
                    <div class="font-semibold text-sm">Coach Bot</div>
                    <div id="ai-level-display" class="text-xs text-gray-400">Level: Medium (1200)</div>
                </div>
            </div>
            <!-- Captured White Pieces -->
            <div id="captured-white" class="flex flex-wrap gap-1 h-8 items-center bg-gray-800/50 rounded-lg px-2 py-1 min-w-[100px]"></div>
        </div>

        <!-- Chess Board Container -->
        <div class="select-none shadow-2xl rounded-sm overflow-hidden border-4 border-gray-700">
           <div id="chessboard" class="grid grid-cols-8 grid-rows-8 w-full max-w-[600px] aspect-square bg-gray-800">
             <!-- Board squares generated by JS -->
           </div>
        </div>

        <!-- Player Info -->
        <div class="w-full max-w-[600px] flex justify-between items-start px-2">
             <div class="flex items-center gap-3">
                <div class="w-10 h-10 rounded-full bg-gradient-to-br from-red-500 to-red-600 flex items-center justify-center text-xs font-bold shadow-lg text-white">
                    You
                </div>
                <div>
                    <div class="font-semibold text-sm">You</div>
                    <div id="game-status" class="text-xs text-gray-400">Active</div>
                </div>
            </div>
             <!-- Captured Black Pieces -->
             <div id="captured-black" class="flex flex-wrap gap-1 h-8 items-center bg-gray-800/50 rounded-lg px-2 py-1 min-w-[100px]"></div>
        </div>
      </div>

      <!-- Right Column: Sidebar -->
      <div class="w-full lg:w-80 flex flex-col gap-6">
          
          <!-- Commentary Box -->
          <div class="bg-gray-800 rounded-xl p-6 border border-gray-700 shadow-xl relative overflow-hidden group">
              <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
                  <svg class="w-16 h-16 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>
              </div>
              <h3 class="text-emerald-400 font-bold mb-2 flex items-center gap-2">
                  <span class="animate-pulse">‚óè</span> Coach Commentary
              </h3>
              <p id="commentary-text" class="text-gray-300 text-sm leading-relaxed min-h-[60px] italic">
                  "Welcome to Grandmaster AI Chess. Good luck!"
              </p>
              <p id="thinking-indicator" class="text-xs text-gray-500 mt-2 animate-pulse hidden">Coach is thinking...</p>
          </div>

          <!-- Controls -->
          <div class="bg-gray-800 rounded-xl p-6 border border-gray-700 shadow-xl space-y-4">
              <h3 class="text-white font-bold mb-4">Game Controls</h3>
              
              <!-- Color Selection -->
              <div>
                  <label class="text-xs text-gray-400 block mb-2">Play As</label>
                  <div class="flex bg-gray-700 rounded-lg p-1 gap-1">
                      <button id="btn-play-white" class="flex-1 py-2 text-xs font-medium rounded-md bg-gray-600 text-white shadow-sm transition-all">White</button>
                      <button id="btn-play-black" class="flex-1 py-2 text-xs font-medium rounded-md text-gray-400 hover:text-white transition-all">Black</button>
                  </div>
              </div>

              <!-- Difficulty -->
              <div>
                  <label class="text-xs text-gray-400 block mb-2">Difficulty</label>
                  <div class="flex flex-col gap-2" id="difficulty-controls">
                      <button data-level="1" class="difficulty-btn w-full flex justify-between items-center py-2 px-3 text-xs font-medium rounded-lg bg-gray-700 text-gray-400 hover:bg-gray-600 transition-colors">
                          <span>Easy</span>
                          <span class="opacity-60 text-[10px]"></span>
                      </button>
                      <button data-level="2" class="difficulty-btn w-full flex justify-between items-center py-2 px-3 text-xs font-medium rounded-lg bg-emerald-600 text-white shadow-lg transition-colors">
                          <span>Medium</span>
                          <span class="opacity-60 text-[10px]"></span>
                      </button>
                      <button data-level="3" class="difficulty-btn w-full flex justify-between items-center py-2 px-3 text-xs font-medium rounded-lg bg-gray-700 text-gray-400 hover:bg-gray-600 transition-colors text-purple-300 border border-purple-900/50">
                          <span>Grandmaster</span>
                          <span class="opacity-60 text-[10px]"></span>
                      </button>
                  </div>
              </div>

              <div class="flex gap-2 pt-2">
                  <button id="btn-reset" class="flex-1 bg-red-500/10 hover:bg-red-500/20 text-red-400 border border-red-500/50 py-3 rounded-lg text-sm font-semibold transition-all hover:shadow-red-900/20">
                      Reset Game
                  </button>
                   <button id="btn-hint" class="flex-1 bg-indigo-500/10 hover:bg-indigo-500/20 text-indigo-400 border border-indigo-500/50 py-3 rounded-lg text-sm font-semibold transition-all">
                      Hint
                  </button>
              </div>
          </div>
      </div>
    </div>

    <!-- MAIN APPLICATION LOGIC -->
    <script type="module">
        import { Chess } from 'chess.js';
        import { GoogleGenAI } from "@google/genai";

        // --- CONSTANTS ---
        const PIECE_IMAGES = {
            'wp': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg',
            'wn': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
            'wb': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
            'wr': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
            'wq': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
            'wk': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
            'bp': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
            'bn': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
            'bb': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
            'br': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
            'bq': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
            'bk': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg',
        };

        const INITIAL_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

        // --- ENGINE SERVICES ---
        
        const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

        // Simplified Piece-Square Tables
        const PSTS = {
            p: [0, 0, 0, 0, 0, 0, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 10, 10, 20, 30, 30, 20, 10, 10, 5, 5, 10, 25, 25, 10, 5, 5, 0, 0, 0, 20, 20, 0, 0, 0, 5, -5, -10, 0, 0, -10, -5, 5, 5, 10, 10, -20, -20, 10, 10, 5, 0, 0, 0, 0, 0, 0, 0, 0],
            n: [-50, -40, -30, -30, -30, -30, -40, -50, -40, -20, 0, 0, 0, 0, -20, -40, -30, 0, 10, 15, 15, 10, 0, -30, -30, 5, 15, 20, 20, 15, 5, -30, -30, 0, 15, 20, 20, 15, 0, -30, -30, 5, 10, 15, 15, 10, 5, -30, -40, -20, 0, 5, 5, 0, -20, -40, -50, -40, -30, -30, -30, -30, -40, -50],
            b: [-20, -10, -10, -10, -10, -10, -10, -20, -10, 0, 0, 0, 0, 0, 0, -10, -10, 0, 5, 10, 10, 5, 0, -10, -10, 5, 5, 10, 10, 5, 5, -10, -10, 0, 10, 10, 10, 10, 0, -10, -10, 10, 10, 10, 10, 10, 10, -10, -10, 5, 0, 0, 0, 0, 5, -10, -20, -10, -10, -10, -10, -10, -10, -20]
        };

        const evaluateBoard = (gameInstance) => {
            let totalEvaluation = 0;
            const board = gameInstance.board();
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece) {
                        const value = PIECE_VALUES[piece.type];
                        let pstValue = 0;
                        if (PSTS[piece.type]) {
                            const index = piece.color === 'w' ? (i * 8 + j) : ((7 - i) * 8 + j);
                            pstValue = PSTS[piece.type][index];
                        }
                        const absoluteValue = value + pstValue;
                        totalEvaluation += piece.color === 'w' ? absoluteValue : -absoluteValue;
                    }
                }
            }
            return totalEvaluation;
        };

        const orderMoves = (moves) => {
            return moves.sort((a, b) => {
                let scoreA = 0; 
                let scoreB = 0;
                
                // Prioritize Captures
                if (a.includes('x')) scoreA += 10;
                if (b.includes('x')) scoreB += 10;
                
                // Prioritize Checks
                if (a.includes('+')) scoreA += 5;
                if (b.includes('+')) scoreB += 5;
                
                // Prioritize Promotions
                if (a.includes('=')) scoreA += 20;
                if (b.includes('=')) scoreB += 20;

                return scoreB - scoreA;
            });
        };

        const minimax = (gameInstance, depth, alpha, beta, isMaximizingPlayer) => {
            if (depth === 0 || gameInstance.isGameOver()) {
                return -evaluateBoard(gameInstance);
            }
            
            let moves = gameInstance.moves();
            moves = orderMoves(moves);

            if (isMaximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    gameInstance.move(move);
                    const evalValue = minimax(gameInstance, depth - 1, alpha, beta, false);
                    gameInstance.undo();
                    maxEval = Math.max(maxEval, evalValue);
                    alpha = Math.max(alpha, evalValue);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    gameInstance.move(move);
                    const evalValue = minimax(gameInstance, depth - 1, alpha, beta, true);
                    gameInstance.undo();
                    minEval = Math.min(minEval, evalValue);
                    beta = Math.min(beta, evalValue);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        };

        const getBestMove = (gameInstance, difficulty) => {
            const possibleMoves = gameInstance.moves();
            if (possibleMoves.length === 0) return null;
            
            // --- ELO ~400 (Easy) ---
            // Simulates a beginner. 
            // - 60% chance to just play a random legal move (blunder potential).
            // - 40% chance to look 1 move ahead (capturing pieces if free).
            if (difficulty === 1) {
                if (Math.random() < 0.6) {
                    // Total random blunder
                    return possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                } else {
                    // Shallow depth (1 or 2)
                    const searchDepth = 1;
                    let bestMove = possibleMoves[0];
                    let bestValue = -Infinity;
                    
                    for (const move of possibleMoves) {
                        gameInstance.move(move);
                        const value = -evaluateBoard(gameInstance); // Simple 1-ply search
                        gameInstance.undo();
                        // Add randomness to evaluation to simulate misjudgment
                        const noise = (Math.random() - 0.5) * 50;
                        if (value + noise > bestValue) {
                            bestValue = value + noise;
                            bestMove = move;
                        }
                    }
                    return bestMove;
                }
            }

            // --- ELO Settings for Medium & GM ---
            
            // Search Depth
            // Medium (1200): Depth 3 (Solid club player)
            // GM (2800): Depth 4 (Deep calculation, considering JS performance)
            const searchDepth = difficulty === 3 ? 4 : 3;
            
            // Analyze moves
            let rankedMoves = [];
            const sortedMoves = orderMoves(possibleMoves);

            // Time management check (simplified for this context)
            const startTime = Date.now();

            for (const move of sortedMoves) {
                gameInstance.move(move);
                // Minimax
                const boardValue = minimax(gameInstance, searchDepth - 1, -100000, 100000, false);
                gameInstance.undo();
                
                rankedMoves.push({ move, value: boardValue });

                // Bail out if taking too long (UX safety)
                if (Date.now() - startTime > 1500 && difficulty !== 3) break;
            }

            // Sort best to worst
            rankedMoves.sort((a, b) => b.value - a.value);
            
            if (rankedMoves.length === 0) return possibleMoves[0];

            const bestValue = rankedMoves[0].value;
            
            // --- ELO 2800 (Grandmaster) ---
            // Always picks the Top 1 move. Ruthless.
            if (difficulty === 3) {
                return rankedMoves[0].move;
            }

            // --- ELO 1200 (Medium) ---
            // "Human-like" tolerance.
            // Doesn't necessarily pick the #1 engine move if #2 or #3 are close enough in score.
            // Tolerance 40cp (centipawns).
            const tolerance = 40; 
            const goodMoves = rankedMoves.filter(m => m.value >= bestValue - tolerance);
            
            // Small chance (10%) to pick from a wider pool (small mistake)
            if (Math.random() < 0.1 && rankedMoves.length > 1) {
                return rankedMoves[1].move;
            }

            // Pick random from "good" moves
            return goodMoves[Math.floor(Math.random() * goodMoves.length)].move;
        };

        // --- GEMINI SERVICES ---

        let aiClient = null;
        let apiQuotaExceeded = false;
        let lastApiCallTime = 0;
        const API_COOLDOWN = 8000; // Increased cooldown to prevent rapid fire

        const getAIClient = () => {
            if (!aiClient && process.env.API_KEY) {
                aiClient = new GoogleGenAI({ apiKey: process.env.API_KEY });
            }
            return aiClient;
        };

        const checkQuotaError = (error) => {
            if (!error) return false;
            
            // Check structured Gemini/Google errors
            if (error.status === 429 || error.code === 429) return true;
            if (error.error && (error.error.code === 429 || error.error.status === "RESOURCE_EXHAUSTED")) return true;
            
            // Check string messages
            const errStr = error.toString();
            const errMsg = error.message || "";
            if (errStr.includes("429") || errMsg.includes("429") || errMsg.includes("Quota") || errMsg.includes("RESOURCE_EXHAUSTED")) {
                return true;
            }
            
            // Check stringified JSON
            try {
                if (JSON.stringify(error).includes("RESOURCE_EXHAUSTED")) return true;
            } catch(e) {}

            return false;
        };

        const getGameCommentary = async (fen, lastMove, history) => {
            if (apiQuotaExceeded) return "The Grandmaster is taking a coffee break (Quota limit).";
            
            const now = Date.now();
            if (now - lastApiCallTime < API_COOLDOWN) return "Hmm...";

            const client = getAIClient();
            if (!client) return "Gemini API Key missing.";
            
            try {
                lastApiCallTime = now;
                const prompt = `
                    You are a witty, sarcastic, yet insightful Chess Grandmaster commentator.
                    Current Board FEN: ${fen}
                    Last Move: ${lastMove}
                    Game History: ${history.slice(-5).join(', ')}...
                    Provide a very short (max 2 sentences) commentary.
                `;
                const response = await client.models.generateContent({
                    model: 'gemini-2.5-flash',
                    contents: prompt,
                });
                return response.text || "Analyzing position...";
            } catch (error) {
                console.error("Gemini Error:", error);
                
                if (checkQuotaError(error)) {
                     apiQuotaExceeded = true;
                     setTimeout(() => apiQuotaExceeded = false, 120000); // 2 minute timeout
                     return "I need a long break. (Quota Limit Reached).";
                }
                return "The Grandmaster is silent.";
            }
        };

        const getHint = async (fen, turn, bestMoveSan) => {
            if (apiQuotaExceeded) return "Coach is resting (Quota limit).";

            const client = getAIClient();
            if (!client) return "Gemini API Key missing.";
            try {
                const prompt = `
                    You are a Chess Coach. 
                    The Board FEN is: ${fen}. 
                    It is ${turn === 'w' ? 'White' : 'Black'}'s turn.
                    
                    The Engine calculates the best move is: "${bestMoveSan}".
                    
                    Give the player a hint to find this move (or a similar good idea). 
                    Do NOT explicitly name the square or piece if possible, describe the idea (e.g. "Control the open file", "Look at the weak pawn").
                    If it's a tactic, say "Look for a tactic".
                    Keep it under 30 words.
                `;
                const response = await client.models.generateContent({
                    model: 'gemini-2.5-flash',
                    contents: prompt,
                });
                return response.text || "Try to control the center.";
            } catch (error) {
                console.error("Gemini Error (Hint):", error);
                if (checkQuotaError(error)) {
                     apiQuotaExceeded = true;
                     setTimeout(() => apiQuotaExceeded = false, 120000);
                     return "Quota exceeded. Try again later.";
                }
                return "Develop your pieces.";
            }
        };

        // --- MAIN APP LOGIC ---

        // State
        let game = new Chess(INITIAL_FEN);
        let playerSide = 'w';
        let boardOrientation = 'w';
        let difficulty = 2; // 1: Easy, 2: Medium, 3: Hard/GM
        let selectedSquare = null;
        let possibleMoves = [];
        let lastMove = null;
        let isAiThinking = false;

        // Elements
        const boardEl = document.getElementById('chessboard');
        const commentaryEl = document.getElementById('commentary-text');
        const thinkingEl = document.getElementById('thinking-indicator');
        const statusEl = document.getElementById('game-status');
        const capturedWhiteEl = document.getElementById('captured-white');
        const capturedBlackEl = document.getElementById('captured-black');
        const aiLevelDisplayEl = document.getElementById('ai-level-display');

        function init() {
            renderBoard();
            updateUI();
            setupControls();
        }

        function setupControls() {
            // Difficulty
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const btnElement = e.currentTarget;
                    const level = parseInt(btnElement.getAttribute('data-level') || '2');
                    setDifficulty(level);
                });
            });

            // Side Selection
            document.getElementById('btn-play-white').addEventListener('click', () => setPlayerSide('w'));
            document.getElementById('btn-play-black').addEventListener('click', () => setPlayerSide('b'));

            // Actions
            document.getElementById('btn-reset')?.addEventListener('click', resetGame);
            document.getElementById('btn-hint')?.addEventListener('click', handleHint);
        }

        function setPlayerSide(side) {
            if(playerSide === side) return;
            playerSide = side;
            boardOrientation = side;

            const wBtn = document.getElementById('btn-play-white');
            const bBtn = document.getElementById('btn-play-black');
            
            if (side === 'w') {
                wBtn.className = "flex-1 py-2 text-xs font-medium rounded-md bg-gray-600 text-white shadow-sm transition-all";
                bBtn.className = "flex-1 py-2 text-xs font-medium rounded-md text-gray-400 hover:text-white transition-all";
            } else {
                wBtn.className = "flex-1 py-2 text-xs font-medium rounded-md text-gray-400 hover:text-white transition-all";
                bBtn.className = "flex-1 py-2 text-xs font-medium rounded-md bg-gray-600 text-white shadow-sm transition-all";
            }

            resetGame();
        }

        function setDifficulty(level) {
            difficulty = level;
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                const btnLevel = parseInt(btn.getAttribute('data-level') || '0');
                
                // Reset basic styles
                let baseClass = "difficulty-btn w-full flex justify-between items-center py-2 px-3 text-xs font-medium rounded-lg transition-colors ";
                
                if (btnLevel === level) {
                    // Active State
                    btn.className = baseClass + "bg-emerald-600 text-white shadow-lg";
                } else {
                    // Inactive State
                    btn.className = baseClass + "bg-gray-700 text-gray-400 hover:bg-gray-600";
                }
                
                // Special GM styling
                if (btnLevel === 3) {
                     if (btnLevel === level) {
                        btn.className = "difficulty-btn w-full flex justify-between items-center py-2 px-3 text-xs font-medium rounded-lg bg-purple-600 text-white shadow-lg shadow-purple-900/50 transition-colors border border-purple-400";
                     } else {
                        btn.className = "difficulty-btn w-full flex justify-between items-center py-2 px-3 text-xs font-medium rounded-lg bg-gray-800 text-purple-400 border border-purple-900/50 hover:bg-gray-700 transition-colors";
                     }
                }
            });
            let levelName = level === 1 ? 'Easy (400)' : (level === 3 ? 'Grandmaster (2800)' : 'Medium (1200)');
            aiLevelDisplayEl.textContent = `Level: ${levelName}`;
            
            aiLevelDisplayEl.classList.add('animate-pulse');
            setTimeout(() => aiLevelDisplayEl.classList.remove('animate-pulse'), 500);
        }

        function handleSquareClick(square) {
            if (game.isGameOver() || isAiThinking || game.turn() !== playerSide) return;

            if (selectedSquare === square) {
                clearSelection();
                renderBoard();
                return;
            }

            const moveAttempt = game.moves({ verbose: true }).find(m => m.from === selectedSquare && m.to === square);

            if (moveAttempt) {
                makeMove(selectedSquare, square);
                clearSelection();
            } else {
                const piece = game.get(square);
                if (piece && piece.color === game.turn() && piece.color === playerSide) {
                    selectedSquare = square;
                    possibleMoves = game.moves({ square: square, verbose: true }).map(m => m.to);
                    renderBoard();
                } else {
                    clearSelection();
                    renderBoard();
                }
            }
        }

        function clearSelection() {
            selectedSquare = null;
            possibleMoves = [];
        }

        function makeMove(from, to) {
            try {
                const move = game.move({ from, to, promotion: 'q' });
                if (!move) return;

                lastMove = { from, to };
                renderBoard();
                updateUI();
                
                const now = Date.now();
                if (now - lastApiCallTime > API_COOLDOWN) {
                     getGameCommentary(game.fen(), move.san, game.history()).then(text => {
                        commentaryEl.textContent = `"${text}"`;
                    });
                }

                if (!game.isGameOver()) {
                    isAiThinking = true;
                    thinkingEl.classList.remove('hidden');
                    setTimeout(makeAiMove, 500);
                }
            } catch (e) {
                console.error("Move error", e);
            }
        }

        function makeAiMove() {
            if (game.isGameOver()) return;

            const bestMoveSan = getBestMove(game, difficulty);
            
            if (bestMoveSan) {
                const move = game.move(bestMoveSan);
                lastMove = { from: move.from, to: move.to };
                
                if (Math.random() > 0.7) {
                     getGameCommentary(game.fen(), move.san, game.history()).then(text => {
                        commentaryEl.textContent = `"${text}"`;
                    });
                }
            }
            
            isAiThinking = false;
            thinkingEl.classList.add('hidden');
            renderBoard();
            updateUI();
        }

        async function handleHint() {
            if (game.isGameOver()) return;
            
            const btnHint = document.getElementById('btn-hint');
            const originalText = btnHint.textContent;
            btnHint.textContent = "Thinking...";
            btnHint.disabled = true;
            
            commentaryEl.textContent = "Coach is analyzing the position...";
            
            // 1. Ask Engine for best move (Depth 3 for quick but accurate result)
            const bestMoveSan = getBestMove(game, 3); // Force decent depth
            
            // 2. Ask Gemini to generate hint based on that move
            const hint = await getHint(game.fen(), game.turn(), bestMoveSan);
            
            commentaryEl.textContent = `Coach Hint: "${hint}"`;
            
            btnHint.textContent = originalText;
            btnHint.disabled = false;
        }

        function resetGame() {
            game = new Chess(INITIAL_FEN);
            lastMove = null;
            clearSelection();
            commentaryEl.textContent = "New game started. Good luck!";
            renderBoard();
            updateUI();

            if (playerSide === 'b' && game.turn() === 'w') {
                isAiThinking = true;
                thinkingEl.classList.remove('hidden');
                setTimeout(makeAiMove, 1000);
            }
        }

        function updateUI() {
            if (game.isCheckmate()) {
                statusEl.textContent = `Checkmate! ${game.turn() === 'w' ? 'Black' : 'White'} wins.`;
                statusEl.className = "text-xs text-red-400 font-bold";
            } else if (game.isDraw()) {
                statusEl.textContent = 'Draw!';
                statusEl.className = "text-xs text-yellow-400 font-bold";
            } else if (game.inCheck()) {
                statusEl.textContent = 'Check!';
                statusEl.className = "text-xs text-red-400 font-bold animate-pulse";
            } else {
                const turnColor = game.turn() === 'w' ? 'White' : 'Black';
                statusEl.textContent = `${turnColor}'s Turn`;
                statusEl.className = "text-xs text-gray-400";
            }
            renderCapturedPieces();
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            const boardState = game.board();
            const rows = boardOrientation === 'w' ? [0, 1, 2, 3, 4, 5, 6, 7] : [7, 6, 5, 4, 3, 2, 1, 0];
            const cols = boardOrientation === 'w' ? [0, 1, 2, 3, 4, 5, 6, 7] : [7, 6, 5, 4, 3, 2, 1, 0];

            rows.forEach(row => {
                cols.forEach(col => {
                    const squareFile = String.fromCharCode(97 + col);
                    const squareRank = 8 - row;
                    const squareId = `${squareFile}${squareRank}`;
                    const piece = boardState[row][col];

                    const cell = document.createElement('div');
                    let classes = ['square', 'w-full', 'h-full'];
                    const isDark = (row + col) % 2 !== 0;
                    classes.push(isDark ? 'bg-board-dark' : 'bg-board-light');
                    
                    if (selectedSquare === squareId) {
                        classes.push('ring-inset', 'ring-4', 'ring-yellow-400');
                    }

                    cell.className = classes.join(' ');
                    cell.onclick = () => handleSquareClick(squareId);

                    if (col === (boardOrientation === 'w' ? 0 : 7)) {
                        const rankLabel = document.createElement('span');
                        rankLabel.className = `absolute top-0.5 left-0.5 text-[10px] font-bold ${!isDark ? 'text-board-dark' : 'text-board-light'}`;
                        rankLabel.innerText = squareRank.toString();
                        cell.appendChild(rankLabel);
                    }
                    if (row === (boardOrientation === 'w' ? 7 : 0)) {
                        const fileLabel = document.createElement('span');
                        fileLabel.className = `absolute bottom-0 right-0.5 text-[10px] font-bold ${!isDark ? 'text-board-dark' : 'text-board-light'}`;
                        fileLabel.innerText = squareFile;
                        cell.appendChild(fileLabel);
                    }

                    if (lastMove && (lastMove.from === squareId || lastMove.to === squareId)) {
                        const overlay = document.createElement('div');
                        overlay.className = "absolute inset-0 bg-yellow-200 opacity-40 mix-blend-multiply pointer-events-none";
                        cell.appendChild(overlay);
                    }

                    const isPossible = possibleMoves.includes(squareId);
                    if (isPossible) {
                        const hint = document.createElement('div');
                        hint.className = piece ? 'capture-hint' : 'move-hint';
                        cell.appendChild(hint);
                    }

                    if (piece) {
                        const img = document.createElement('img');
                        img.src = PIECE_IMAGES[`${piece.color}${piece.type}`];
                        img.className = 'piece';
                        cell.appendChild(img);
                    }

                    boardEl.appendChild(cell);
                });
            });
        }

        function renderCapturedPieces() {
            const boardState = game.board();
            const currentCounts = {};
            boardState.flat().forEach(p => {
                if(p) {
                    const key = `${p.color}${p.type}`;
                    currentCounts[key] = (currentCounts[key] || 0) + 1;
                }
            });

            const initialCounts = {
                'wp': 8, 'wr': 2, 'wn': 2, 'wb': 2, 'wq': 1,
                'bp': 8, 'br': 2, 'bn': 2, 'bb': 2, 'bq': 1
            };

            const wCaps = [];
            const bCaps = [];

            Object.keys(initialCounts).forEach(key => {
                if (key.startsWith('w')) {
                    const count = currentCounts[key] || 0;
                    const missing = initialCounts[key] - count;
                    for(let i=0; i<missing; i++) wCaps.push(key[1]);
                }
            });
             Object.keys(initialCounts).forEach(key => {
                if (key.startsWith('b')) {
                    const count = currentCounts[key] || 0;
                    const missing = initialCounts[key] - count;
                    for(let i=0; i<missing; i++) bCaps.push(key[1]);
                }
            });

            const createImgs = (container, pieces, color) => {
                container.innerHTML = '';
                if(pieces.length === 0) {
                    const span = document.createElement('span');
                    span.className = "text-xs text-gray-500";
                    span.innerText = "None";
                    container.appendChild(span);
                    return;
                }
                pieces.forEach(p => {
                    const img = document.createElement('img');
                    img.src = PIECE_IMAGES[`${color}${p}`];
                    img.className = "w-5 h-5 opacity-80";
                    container.appendChild(img);
                });
            };

            createImgs(capturedWhiteEl, wCaps, 'w');
            createImgs(capturedBlackEl, bCaps, 'b');
        }

        init();
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>